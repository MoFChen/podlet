mod container;
mod install;
mod kube;
mod network;
mod volume;

use std::{
    fmt::{self, Display, Formatter, Write},
    str::FromStr,
};

use thiserror::Error;

pub use self::{
    container::{Container, PullPolicy},
    install::Install,
    kube::Kube,
    network::Network,
    volume::Volume,
};
use crate::cli::{service::Service, unit::Unit};

#[derive(Debug, Clone, PartialEq)]
pub struct File {
    pub name: String,
    pub unit: Option<Unit>,
    pub resource: Resource,
    pub service: Option<Service>,
    pub install: Option<Install>,
}

impl Display for File {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        if let Some(unit) = &self.unit {
            writeln!(f, "{unit}")?;
        }

        write!(f, "{}", self.resource)?;

        if let Some(service) = &self.service {
            write!(f, "\n{service}")?;
        }

        if let Some(install) = &self.install {
            write!(f, "\n{install}")?;
        }

        Ok(())
    }
}

impl File {
    /// Returns the corresponding service file name generated by quadlet
    pub fn service_name(&self) -> String {
        self.resource.name_to_service(&self.name)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Resource {
    Container(Box<Container>),
    Kube(Kube),
    Network(Network),
    Volume(Volume),
}

impl Display for Resource {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            Self::Container(container) => write!(f, "{container}"),
            Self::Kube(kube) => write!(f, "{kube}"),
            Self::Network(network) => write!(f, "{network}"),
            Self::Volume(volume) => write!(f, "{volume}"),
        }
    }
}

impl From<Container> for Resource {
    fn from(value: Container) -> Self {
        Self::Container(Box::new(value))
    }
}

impl From<Box<Container>> for Resource {
    fn from(value: Box<Container>) -> Self {
        Self::Container(value)
    }
}

impl From<Kube> for Resource {
    fn from(value: Kube) -> Self {
        Self::Kube(value)
    }
}

impl From<Network> for Resource {
    fn from(value: Network) -> Self {
        Self::Network(value)
    }
}

impl From<Volume> for Resource {
    fn from(value: Volume) -> Self {
        Self::Volume(value)
    }
}

impl Resource {
    /// Returns the extension that should be used for the generated file
    pub fn extension(&self) -> &'static str {
        match self {
            Self::Container { .. } => "container",
            Self::Kube { .. } => "kube",
            Self::Network { .. } => "network",
            Self::Volume { .. } => "volume",
        }
    }

    /// Takes a file name (no extension) and returns the corresponding service file name
    /// generated by quadlet
    pub fn name_to_service(&self, name: &str) -> String {
        let mut service = match self {
            Self::Container { .. } | Self::Kube { .. } => String::from(name),
            Self::Network { .. } => format!("{name}-network"),
            Self::Volume { .. } => format!("{name}-volume"),
        };
        service.push_str(".service");
        service
    }
}

/// Valid values for the `AutoUpdate=` quadlet option.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AutoUpdate {
    Registry,
    Local,
}

impl AutoUpdate {
    /// Extracts all valid values of the `io.containers.autoupdate` label from `labels`,
    /// the last value of which is parsed into an [`AutoUpdate`].
    ///
    /// Returns `None` if no valid `io.containers.autoupdate` label is found.
    ///
    /// `io.containers.autoupdate` labels with invalid values are retained in `labels`.
    pub fn extract_from_labels(labels: &mut Vec<String>) -> Option<Self> {
        let mut auto_update = None;
        labels.retain(|label| {
            label
                .strip_prefix("io.containers.autoupdate=")
                .and_then(|value| value.parse().ok())
                .map_or(true, |value| {
                    auto_update = Some(value);
                    false
                })
        });

        auto_update
    }
}

impl AsRef<str> for AutoUpdate {
    fn as_ref(&self) -> &str {
        match self {
            Self::Registry => "registry",
            Self::Local => "local",
        }
    }
}

impl Display for AutoUpdate {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        f.write_str(self.as_ref())
    }
}

impl FromStr for AutoUpdate {
    type Err = ParseAutoUpdateError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "registry" => Ok(Self::Registry),
            "local" => Ok(Self::Local),
            s => Err(ParseAutoUpdateError(s.into())),
        }
    }
}

/// Error returned when attempting to parse an invalid [`AutoUpdate`] variant,
/// see [`AutoUpdate::from_str()`].
#[derive(Debug, Error)]
#[error("unknown auto update variant `{0}`, must be `registry` or `local`")]
pub struct ParseAutoUpdateError(String);

/// Writes the line `key=joined_words` to the [`Formatter`]. `joined_words` is the given `words`,
/// where each word is escaped and joined together with the const parameter `C` as a separator.
fn writeln_escape_spaces<const C: char, I>(f: &mut Formatter, key: &str, words: I) -> fmt::Result
where
    I: IntoIterator,
    I::Item: AsRef<str>,
{
    write!(f, "{key}=")?;

    let mut words = words.into_iter();

    if let Some(first) = words.next() {
        escape_spaces(f, first.as_ref())?;
    }

    for word in words {
        f.write_char(C)?;
        escape_spaces(f, word.as_ref())?;
    }

    writeln!(f)
}

fn escape_spaces(f: &mut Formatter, word: &str) -> fmt::Result {
    if word.contains(' ') {
        write!(f, "\"{word}\"")
    } else {
        f.write_str(word)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn escape_spaces() {
        struct Foo([&'static str; 3]);

        impl Display for Foo {
            fn fmt(&self, f: &mut Formatter) -> fmt::Result {
                writeln_escape_spaces::<' ', _>(f, "Foo", self.0)
            }
        }

        assert_eq!(
            Foo(["one", "two", "three"]).to_string(),
            "Foo=one two three\n"
        );
        assert_eq!(
            Foo(["one", "two three", "four"]).to_string(),
            "Foo=one \"two three\" four\n"
        );
    }
}
