mod container;
mod install;
mod kube;
mod network;
mod volume;

use std::{
    borrow::Cow,
    fmt::{self, Display, Formatter},
    fs,
    io::{self, Write},
    path::Path,
};

use color_eyre::{
    eyre::{self, WrapErr},
    Help, Report,
};

pub use self::{
    container::Container, install::Install, kube::Kube, network::Network, volume::Volume,
};
use crate::cli::{service::Service, unit::Unit};

#[derive(Debug, Clone, PartialEq)]
pub struct File {
    pub name: String,
    pub unit: Option<Unit>,
    pub resource: Resource,
    pub service: Option<Service>,
    pub install: Option<Install>,
}

impl Display for File {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        if let Some(unit) = &self.unit {
            writeln!(f, "{unit}")?;
        }

        write!(f, "{}", self.resource)?;

        if let Some(service) = &self.service {
            write!(f, "\n{service}")?;
        }

        if let Some(install) = &self.install {
            write!(f, "\n{install}")?;
        }

        Ok(())
    }
}

impl File {
    pub fn write(&self, path: impl AsRef<Path>, overwrite: bool) -> eyre::Result<()> {
        let path_display = path.as_ref().display().to_string();
        let mut file = fs::File::options()
            .write(true)
            .create_new(!overwrite)
            .create(overwrite)
            .open(path)
            .map_err(|error| match error.kind() {
                io::ErrorKind::AlreadyExists => {
                    eyre::eyre!("File already exists, not overwriting it: {path_display}")
                        .suggestion("Use `--overwrite` if you wish overwrite existing files.")
                }
                _ => Report::new(error)
                    .wrap_err(format!("Failed to create/open file: {path_display}"))
                    .suggestion(
                        "Make sure the directory exists \
                                and you have write permissions for the file",
                    ),
            })?;
        write!(file, "{self}")
            .wrap_err_with(|| format!("Failed to write to file: {path_display}"))?;
        println!("Wrote to file: {path_display}");
        Ok(())
    }

    /// Returns the corresponding service file name generated by quadlet
    pub fn service_name(&self) -> String {
        self.resource.name_to_service(&self.name)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Resource {
    Container(Box<Container>),
    Kube(Kube),
    Network(Network),
    Volume(Volume),
}

impl Display for Resource {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            Self::Container(container) => write!(f, "{container}"),
            Self::Kube(kube) => write!(f, "{kube}"),
            Self::Network(network) => write!(f, "{network}"),
            Self::Volume(volume) => write!(f, "{volume}"),
        }
    }
}

impl From<Container> for Resource {
    fn from(value: Container) -> Self {
        Self::Container(Box::new(value))
    }
}

impl From<Box<Container>> for Resource {
    fn from(value: Box<Container>) -> Self {
        Self::Container(value)
    }
}

impl From<Kube> for Resource {
    fn from(value: Kube) -> Self {
        Self::Kube(value)
    }
}

impl From<Network> for Resource {
    fn from(value: Network) -> Self {
        Self::Network(value)
    }
}

impl From<Volume> for Resource {
    fn from(value: Volume) -> Self {
        Self::Volume(value)
    }
}

impl Resource {
    /// Returns the extension that should be used for the generated file
    pub fn extension(&self) -> &'static str {
        match self {
            Self::Container { .. } => "container",
            Self::Kube { .. } => "kube",
            Self::Network { .. } => "network",
            Self::Volume { .. } => "volume",
        }
    }

    /// Takes a file name (no extension) and returns the corresponding service file name
    /// generated by quadlet
    pub fn name_to_service(&self, name: &str) -> String {
        let mut service = match self {
            Self::Container { .. } | Self::Kube { .. } => String::from(name),
            Self::Network { .. } => format!("{name}-network"),
            Self::Volume { .. } => format!("{name}-volume"),
        };
        service.push_str(".service");
        service
    }
}

fn escape_spaces_join<'a>(words: impl IntoIterator<Item = &'a String>) -> String {
    words
        .into_iter()
        .map(|word| {
            if word.contains(' ') {
                format!("\"{word}\"").into()
            } else {
                word.into()
            }
        })
        .collect::<Vec<Cow<_>>>()
        .join(" ")
}
