mod container;
mod install;
mod kube;
mod network;
mod volume;

use std::fmt::{self, Display, Formatter, Write};

pub use self::{
    container::Container, install::Install, kube::Kube, network::Network, volume::Volume,
};
use crate::cli::{service::Service, unit::Unit};

#[derive(Debug, Clone, PartialEq)]
pub struct File {
    pub name: String,
    pub unit: Option<Unit>,
    pub resource: Resource,
    pub service: Option<Service>,
    pub install: Option<Install>,
}

impl Display for File {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        if let Some(unit) = &self.unit {
            writeln!(f, "{unit}")?;
        }

        write!(f, "{}", self.resource)?;

        if let Some(service) = &self.service {
            write!(f, "\n{service}")?;
        }

        if let Some(install) = &self.install {
            write!(f, "\n{install}")?;
        }

        Ok(())
    }
}

impl File {
    /// Returns the corresponding service file name generated by quadlet
    pub fn service_name(&self) -> String {
        self.resource.name_to_service(&self.name)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Resource {
    Container(Box<Container>),
    Kube(Kube),
    Network(Network),
    Volume(Volume),
}

impl Display for Resource {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            Self::Container(container) => write!(f, "{container}"),
            Self::Kube(kube) => write!(f, "{kube}"),
            Self::Network(network) => write!(f, "{network}"),
            Self::Volume(volume) => write!(f, "{volume}"),
        }
    }
}

impl From<Container> for Resource {
    fn from(value: Container) -> Self {
        Self::Container(Box::new(value))
    }
}

impl From<Box<Container>> for Resource {
    fn from(value: Box<Container>) -> Self {
        Self::Container(value)
    }
}

impl From<Kube> for Resource {
    fn from(value: Kube) -> Self {
        Self::Kube(value)
    }
}

impl From<Network> for Resource {
    fn from(value: Network) -> Self {
        Self::Network(value)
    }
}

impl From<Volume> for Resource {
    fn from(value: Volume) -> Self {
        Self::Volume(value)
    }
}

impl Resource {
    /// Returns the extension that should be used for the generated file
    pub fn extension(&self) -> &'static str {
        match self {
            Self::Container { .. } => "container",
            Self::Kube { .. } => "kube",
            Self::Network { .. } => "network",
            Self::Volume { .. } => "volume",
        }
    }

    /// Takes a file name (no extension) and returns the corresponding service file name
    /// generated by quadlet
    pub fn name_to_service(&self, name: &str) -> String {
        let mut service = match self {
            Self::Container { .. } | Self::Kube { .. } => String::from(name),
            Self::Network { .. } => format!("{name}-network"),
            Self::Volume { .. } => format!("{name}-volume"),
        };
        service.push_str(".service");
        service
    }
}

fn writeln_escape_spaces<I>(f: &mut Formatter, key: &str, words: I) -> fmt::Result
where
    I: IntoIterator,
    I::Item: AsRef<str>,
{
    write!(f, "{key}=")?;

    let mut words = words.into_iter();

    if let Some(first) = words.next() {
        escape_spaces(f, first.as_ref())?;
    }

    for word in words {
        f.write_char(' ')?;
        escape_spaces(f, word.as_ref())?;
    }

    writeln!(f)
}

fn escape_spaces(f: &mut Formatter, word: &str) -> fmt::Result {
    if word.contains(' ') {
        write!(f, "\"{word}\"")
    } else {
        f.write_str(word)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn escape_spaces() {
        struct Foo([&'static str; 3]);

        impl Display for Foo {
            fn fmt(&self, f: &mut Formatter) -> fmt::Result {
                writeln_escape_spaces(f, "Foo", self.0)
            }
        }

        assert_eq!(
            Foo(["one", "two", "three"]).to_string(),
            "Foo=one two three\n"
        );
        assert_eq!(
            Foo(["one", "two three", "four"]).to_string(),
            "Foo=one \"two three\" four\n"
        );
    }
}
